<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

</body>
</html>

<script type="text/javascript">
    // Your ES6 code
    // ——————————————————————————————————————————————————————

    // ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。
    //    {
    //        var a = 200;
    //        let b = 300;
    //    }
    //    console.log(a);
    //    console.log(b);  // b is not defined

    // ——————————————————————————————————————————————————————
    //    for循环的计数器，就很合适使用let命令。
    //    for (let i = 0; i < 10; i++) {
    //    }
    //    console.log(i);  // ReferenceError: i is not defined
    //    for (var j = 0; j < 10; j++) {
    //    }
    //    console.log(j);  //  10
    //    上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。

    // ——————————————————————————————————————————————————————
    //    var a = [];
    //    for (var i = 0; i < 10; i++) {
    //        a[i] = function () {
    //            console.log(i);
    //        };
    //    }
    //    a[6](); // 10

    //    如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。
    //    var a = [];
    //    for (let i = 0; i < 10; i++) {
    //        a[i] = function () {
    //            console.log(i);
    //        };
    //    }
    //    a[6](); // 6

    // ——————————————————————————————————————————————————————
    //    for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
    //    for (let i = 0; i < 3; i++) {
    //        console.log(i);
    //        let i = 'abc';
    //        console.log(i);
    //    }


    // ——————————————————————————————————————————————————————
    //    let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。
    // var 的情况
    //    console.log(foo); // 输出undefined
    //    var foo = 2;
    //
    //    // let 的情况
    //    console.log(bar); // 报错ReferenceError
    //    let bar = 2;

    // —————————————————————————暂时性死区—————————————————————————————
    //    只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

    //    var tmp = 123;
    //
    //    if (true) {
    //        tmp = 'abc'; // ReferenceError
    //        let tmp;
    //    }

    //ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

    //    if (true) {
    //        // TDZ开始
    //        tmp = 'abc'; // ReferenceError
    //        console.log(tmp); // ReferenceError
    //
    //        let tmp; // TDZ结束
    //        console.log(tmp); // undefined
    //
    //        tmp = 123;
    //        console.log(tmp); // 123
    //    }

    // ——————————————————————————————————————————————————————
    //    “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。
    //    {
    //        console.log(typeof x);  // undefined
    //        console.log(typeof y);  // Error  y is not defined  凡是在声明之前就使用这些变量，就会报错。
    //        let y;
    //    }
    // ——————————————————————————————————————————————————————
    //    function bar(x = y, y = 2) {
    //        return [x, y];
    //    }
    //    bar(); // ReferenceError   y is not defined

    //    function bar(x = 2, y = x) {
    //        return [x, y];
    //    }
    //    console.log(bar()); // [2, 2]

    //    // 不报错
    //    var x = x;
    //    // 报错
    //    let y = y;
    //    // ReferenceError: y is not defined

    // ——————————————————————————不允许重复声明————————————————————————————
    //    let不允许在相同作用域内，重复声明同一个变量
    // 报错
    //    function func() {
    //        let a = 10;
    //        var a = 1;
    //    }
    //
    //    // 报错
    //    function func() {
    //        let a = 10;
    //        let a = 1;
    //    }

    // ——————————————————————————块级作用域————————————————————————————

    //    var tmp = new Date();
    //
    //    function f() {
    //        console.log(tmp);
    //        var tmp = 'hello world';
    //    }
    //
    //    f(); // undefined
    //    //变量提升，导致内层的tmp变量覆盖了外层的tmp变量。

    //    var s = 'hello';
    //
    //    for (var i = 0; i < s.length; i++) {
    //        console.log(s[i]);
    //    }
    //
    //    console.log(i); // 5
    //    //上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。

    // ——————————————————————————ES6 的块级作用域————————————————————————————

    //    function f1() {
    //        let n = 5;
    //        if (true) {
    //            let n = 10;
    //        }
    //        console.log(n); // 5
    //    }
    //
    //    f1();
    //
    //    // 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。

    // ES6 允许块级作用域的任意嵌套。

    //    {
    //        {
    //            {
    //                {
    //                    {
    //                        let insane = 'Hello World'
    //                        console.log(insane)
    //                    }
    //                }
    //            }
    //        }
    //    }

    //上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。
    //    {
    //        {
    //            {
    //                {
    //                    {
    //                        let insane = 'Hello World'
    //                    }
    //                    console.log(insane); // 报错  ReferenceError: insane is not defined
    //                }
    //            }
    //        }
    //    }

    // ——————————————————————————块级作用域与函数声明————————————————————————————

    // ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
    //    // 情况一
    //    if (true) {
    //        function f() {}
    //    }
    //
    //    // 情况二
    //    try {
    //        function f() {}
    //    } catch(e) {
    //        // ...
    //    }

    // 以上代码浏览器中可以通过


    // ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。

    //    -允许在块级作用域内声明函数。
    //    -函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
    //    -同时，函数声明还会提升到所在的块级作用域的头部。


    //    f();
    //    function f() {
    //        console.log('I am outside!');
    //    }
    //
    //    (function () {
    //        f(); // TypeError: f is not a function
    //        {
    //            function f() {
    //                console.log('I am inside!');
    //            }
    //        }
    //        f();
    //    }());


    //    {
    //        if (true){
    //            function f() {
    //                console.log('I am inside!');
    //            }
    //        }
    //        f()
    //    }

    // 以上代码等同于以下
    //    {
    //        var f = undefined;
    //        if (false){
    //            f = function () {
    //                console.log('I am inside!');
    //            }
    //        }
    //        f();
    //    }


    //考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
    //    // 函数声明语句
    //    {
    //        let a = 'secret1';
    //        function f() {
    //            return a;
    //        }
    //    }
    //    console.log(f())  //secret1
    //    // 函数表达式
    //    {
    //        let a = 'secret2';
    //        let f = function () {
    //            return a;
    //        };
    //        console.log(f()) //secret2
    //    }
    //    console.log(f())  //secret1

    // 不报错
    //    'use strict';
    //    if (true) {
    //        function f() {
    //
    //        }
    //    }

    // 报错   SyntaxError: In strict mode code, functions can only be declared at top level or inside a block.
    //    'use strict';
    //    if (true)
    //        function f() {}


    /**
     * ————————————————————【const命令】————————————————————————
     */

    // ——————————————————————————基本用法————————————————————————————

    // const声明一个只读的常量。一旦声明，常量的值就不能改变。

    //    const PI = 3.1415926;
    //
    //    PI = 3;  // 再赋值的时候就会报错   TypeError: Assignment to constant variable.

    // const 声明的变量必须初始化
    //    const PI;  // SyntaxError: Missing initializer in const declaration


    // const 作用域
    //    {
    //        const PI = 3;
    //    }
    //    console.log(PI);   //ReferenceError: PI is not defined


    //const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
    //    {
    //        console.log(MAX); // ReferenceError: MAX is not defined
    //        const MAX = 5;
    //    }


    // const声明的常量，也与let一样不可重复声明。
    //    {
    //        var MAX = 12;
    //        const MAX = 13;
    //        // SyntaxError: Identifier 'MAX' has already been declared
    //    }

    //    {
    //        const MAX = 12;
    //        var MAX = 13;
    //        // SyntaxError: Identifier 'MAX' has already been declared
    //    }

    //    {
    //        const MAX = 12;
    //        const MAX = 13;
    //        // SyntaxError: Identifier 'MAX' has already been declared
    //    }


    //const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
    //    {
    //        const obj = {
    //            name: '朱明宇',
    //            age: 26,
    //            height: 170
    //        }
    //        console.log(obj);
    //        obj.name = '吴天航'; // 此时obj中的name属性改变了
    //        console.log(obj);
    //
    //        obj = {};  // 如果将obj重新指定到一个对象则会报错   TypeError: Assignment to constant variable.
    //    }


    //如果真的想将对象冻结，应该使用Object.freeze方法。
    //    'use strict';
    //    const obj = Object.freeze({
    //        name: '朱明宇',
    //        age: 26,
    //        height: 170
    //    });
    //    obj.name = '吴天航';  // 不会改变值   (严格模式下还会报错 TypeError: Cannot assign to read only property 'name' of object '#<Object>')
    //    console.log(obj);


    //ES6 声明变量的六种方法
    //  es5 :  var、function
    // es6：let、const、import、class


    // ——————————————————————————顶层对象的属性————————————————————————————
    // 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。
    // ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。


    //    var a = 123;
    //    console.log(window.a)
    //
    //    let b = 123;
    //    console.log(window.b)  // undefined

    // ——————————————————————————顶层对象————————————————————————————

    //ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。
    // 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
    // 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。
    // Node 里面，顶层对象是global，但其他环境都不支持。

    // 获取顶层对象的方法
    //        // 方法一
    //    let w = (typeof window !== 'undefined'
    //            ? window
    //            : (typeof process === 'object' &&
    //            typeof require === 'function' &&
    //            typeof global === 'object')
    //                ? global
    //                : this);
    //
    //    console.log(w);
    //
    //    // 方法二
    //    let getGlobal = function () {
    //        if (typeof self !== 'undefined') {
    //            return self;
    //        }
    //        if (typeof window !== 'undefined') {
    //            return window;
    //        }
    //        if (typeof global !== 'undefined') {
    //            return global;
    //        }
    //        throw new Error('unable to locate global object');
    //    };
    //
    //    console.log(getGlobal())


</script>