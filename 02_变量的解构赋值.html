<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

</body>
</html>

<script type="text/javascript">
    // ——————————————————————1. 数组的解构赋值——————————————————————————
    /**
     * ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
     */
    // 最基本的赋值
    //    {
    //        let a = 1;
    //        let b = 2;
    //        let c = 3;
    //        console.log(a);
    //        console.log(b);
    //        console.log(c);
    //    }


    // es6的赋值
    //    {
    //        let [a, b, c] = [1, 2, 3];
    //        console.log(a);
    //        console.log(b);
    //        console.log(c);
    //    }


    // 模式匹配
    //    {
    //        let [a, [b, c]] = [1, [2, 3]];
    //        console.log(a);
    //        console.log(b);
    //        console.log(c);
    //    }

    //    {
    //        let [, , third] = ["foo", "bar", "baz"];
    //        console.log(third) // baz
    //    }

    //    {
    //        let [x, , y] = [1, 2, 3];
    //        console.log(x) // 1
    //        console.log(y) // 3
    //    }

    //    {
    //        let [head, ...tail] = [1, 2, 3, 4];
    //        console.log(head); // 4
    //        console.log(tail) //  [2, 3, 4]
    //    }

    //    {
    //        let [x, y, ...z] = ['a'];
    //        console.log(x); // a
    //        console.log(y); // undefined
    //        console.log(z); // []
    //    }


    // 如果解构不成功，变量的值就等于undefined。
    //    {
    //        let [a, b] = [1];
    //        console.log(a) // 1
    //        console.log(b) // undefined
    //    }

    //    {
    //        let [x, y] = [1, 2, 3];
    //        console.log(x) // 1
    //        console.log(y) // 2
    //    }

    //    {
    //        let [a, [b], d] = [1, [2, 3], 4];
    //        a // 1
    //        b // 2
    //        d // 4
    //    }


    // 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。
    //    {
    //        // 报错       TypeError: 1 is not iterable
    //        let [foo] = 1;
    //        let [foo] = false;
    //        let [foo] = NaN;
    //        let [foo] = undefined;
    //        let [foo] = null;
    //        let [foo] = {};
    //    }


    // 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。
    //    {
    //        let [x, y, z] = new Set(['a', 'b', 'c']);
    //        console.log(x);
    //        console.log(y);
    //        console.log(z);
    //    }

    //    {
    //        function* fibs() {
    //            let a = 0;
    //            let b = 1;
    //            while (true) {
    //                yield a;
    //                [a, b] = [b, a + b];
    //            }
    //        }
    //        let [first, second, third, fourth, fifth, sixth] = fibs();
    //        console.log(sixth)  // 5   原理还不懂
    //    }


    /**
     *  默认值
     */

    //解构赋值允许指定默认值
    //    {
    //        let [foo = true] = [];
    //        console.log(foo)  // true
    //        let [x, y = 'b'] = ['a']; // x='a', y='b'
    //        console.log(x,y)
    //        let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
    //        console.log(x, y)
    //    }


    // 只有当一个数组成员严格等于undefined，默认值才会生效。
    //    {
    //        let [a = 1, b = 2] = [3, undefined];
    //        console.log(a, b) // 3 2
    //        let [x = 1] = [null];
    //        console.log(x) // null
    //    }


    // 如果默认值是一个表达式
    //        {
    //            function f() {
    //                console.log('使用的是默认值哦');
    //                return 123;
    //            }
    //
    //            //let [a = f()] = [1] // 赋值成功，f()的函数不会执行
    //            let [a = f()] = [undefined] // 赋值不成功，会执行f()函数  打印出函数里的值
    //            console.log(a)
    //
    //            // 相当于
    //            let b;
    //            if ([1][0] === undefined){
    //                b = f();
    //            }else {
    //                b = [1][0];
    //            }
    //        }


    // 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
    //    {
    //        let [x = 1, y = x] = [];     // x=1; y=1
    //        let [x = 1, y = x] = [2];    // x=2; y=2
    //        let [x = 1, y = x] = [1, 2]; // x=1; y=2
    //        let [x = y, y = 1] = [];     // ReferenceError: y is not defined
    //    }

    // ——————————————————————2. 对象的解构赋值——————————————————————————

    // 解构不仅可以用于数组，还可以用于对象。
    //    {
    //        let { foo, bar } = { foo: "aaa", bar: "bbb" };
    //        foo // "aaa"
    //        bar // "bbb"
    //        console.log(foo);
    //        console.log(bar);
    //    }


    // 变量赋值不用排序的
    //    {
    //        let {foo, bar} = {bar: 'zhumingyu', foo: 'songyuqing'};
    //        console.log(foo);
    //        console.log(bar);
    //    }


    //如果变量名与属性名不一致，必须写成下面这样
    //    {
    //        let {bar: baz} = {foo: 'aaa', bar: 'bbb'};
    //        //console.log(foo); //ReferenceError: foo is not defined
    //        console.log(baz);
    //
    //        let obj = {first: 'hello', last: 'world'}
    //        let {first: f, last: l} = obj;
    //        console.log(f, l); // hello world
    //    }


    // 这实际上说明，对象的解构赋值是下面形式的简写
    //    {
    //        let {foo: foo, bar: bar} = {foo: "aaa", bar: "bbb"};
    //        console.log(foo); // aaa
    //        console.log(bar); // bbb
    //    }


    //对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者
    //    {
    //        let {foo: baz} = {foo: "aaa", bar: "bbb"};
    //        console.log(baz); // aaa
    //        console.log(foo); //ReferenceError: foo is not defined
    //        // foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。
    //    }


    // 与数组一样，解构也可以用于嵌套结构的对象。
    //    {
    //        let {p, p: [x, {y}]} = {p: ['hello', {y: 'world'}]};
    //        console.log(x, y, p) // hello world
    //    }


    // 嵌套赋值
    //    {
    //        let obj = {};
    //        let arr = [];
    //        ({foo: obj.pro, baz: arr[0]} = {foo: 1, baz: true})
    //        console.log(obj, arr)
    //    }


    // 对象的解构也可以指定默认值。
    //    {
    //        let {a = 1, b = 2} = {a: 3, b: 4};
    //        console.log(a, b);  // 3  4
    //    }


    //默认值生效的条件是，对象的属性值严格等于undefined。
    //    {
    //        let {a = 1, b = 2} = {a: undefined, b: 3};
    //        console.log(a, b);  // 1  3
    //    }


    //如果解构失败，变量的值等于undefined。
    //    {
    //        let {a} = {b: 3};
    //        console.log(a);  // undefined
    //    }


    // 父子对象的解构赋值
    //    {
    //        let {foo: {baz}} = {foo: {baz: 123}};
    //        console.log(baz);
    //    }


    // 将一个已声名的变量解构赋值
    //    {
    //        let x;
    //        // {x} = {x:1}   //  错误写法   因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误  SyntaxError
    //        ({x} = {x: 111})  // 正确写法
    //        console.log(x);
    //    }


    //    {
    //        let {log, sin, cos} = Math;
    //        console.log(cos(180))
    //    }


    //由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。
    //    {
    //        let arr = [1, 2, 3];
    //        let {0: first, 1: second, [arr.length - 1]: last} = arr;
    //        console.log(first)  // 1
    //        console.log(second)  // 2
    //        console.log(last)  // 3
    //    }


    // ——————————————————————3. 字符串的解构赋值——————————————————————————

    /**
     * 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
     */

    //    {
    //        let [a, b, c, d, e] = 'hello';
    //        console.log(a, b, c, d, e)
    //    }


    //    {
    //        let {length} = 'hello';
    //        console.log(length)
    //    }

    // ——————————————————————4. 数值和布尔值的解构赋值——————————————————————————

    //    {
    //        let {toString:to} = 1;
    //        console.log(to === Number.prototype.toString)  // true
    //
    //        let {toString:s} = true;
    //        console.log(s === Boolean.prototype.toString)  // true
    //    }

    // ——————————————————————5. 函数参数的解构赋值——————————————————————————

    // 函数的参数也可以使用解构赋值。
    //    {
    //        function add([x, y]) {
    //            return x + y;
    //        }
    //        console.log(add([2, 3]))
    //    }


    //    [[1, 2], [3, 4]].map(([a, b]) => console.log(a + b))  // 3    7


    //函数参数的解构也可以使用默认值。
    //    {
    //        function add({x = 1, y = 2}) {
    //            return x + y;
    //        }
    //        console.log(add({}))   // 3
    //        console.log(add({x: 3}))  // 5
    //        console.log(add({x: 3, y: 5}))  // 8
    //    }


    //undefined就会触发函数参数的默认值。
    //    {
    //        [1, undefined, 3].map((x = 'yes') => console.log(x))
    //    }


    // ——————————————————————6. 用途——————————————————————————
    // 交换变量的值
    //    {
    //        let x = 1, y = 2;
    //        [x,y] = [y,x];
    //        console.log(x,y)
    //    }


    // 从函数返回多个值
    //    {
    //        // 返回一个数组
    //        function array() {
    //            return [1, 2, 3];
    //        }
    //
    //        let [a, b, c] = array();
    //        console.log(a, b, c) // 1 2 3
    //
    //        // 返回一个对象
    //        function obj() {
    //            return {
    //                x: 1,
    //                y: 2,
    //                z: 3
    //            }
    //        }
    //
    //        let {x: j, y: k, z: l} = obj();
    //        console.log(j, k, l); // 1 2 3
    //    }


    // 函数参数的定义  解构赋值可以方便地将一组参数与变量名对应起来。
    //    {
    //        // 参数是一组有次序的值
    //        function f([x, y, z]) {
    //        }
    //        f([1, 2, 3]);
    //
    //        // 参数是一组无次序的值
    //        function f({x, y, z}) {
    //        }
    //        f({z: 3, y: 2, x: 1});
    //    }


    //提取 JSON 数据
    //    {
    //        let jsonData = {
    //            id: 42,
    //            status: "OK",
    //            data: [867, 5309]
    //        };
    //        let { id, status, data: number } = jsonData;
    //        console.log(id, status, number);
    //    }


    // 函数参数的默认值


    // 遍历Map 结构
    //    {
    //        let map = new Map();
    //        map.set('name', '朱明宇');
    //        map.set('age', 26);
    //        map.set('height', 170);
    //        map.set('weight', 56);
    //
    //        // 遍历1
    //        for (let [key, value] of map) {
    //            console.log(key + '是' + value)
    //        }
    //        // 遍历2
    //        map.forEach((value,key,array)=>{
    //            console.log(key + '是' + value,array)
    //        })
    //
    //        // 只获取键
    //        for(let [key,] of map){
    //            console.log(key)
    //        }
    //
    //        // 只获取值
    //        for(let [,value] of map){
    //            console.log(value)
    //        }
    //    }


    // 输入模块的指定方法
    /**
     * 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。
     */
    //    {
    //        const {SourceMapConsumer, SourceNode} = require("source-map");
    //    }


</script>