<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

</body>
</html>

<script type="text/javascript">
    // ——————————————————————01. 函数参数的默认值 ——————————————————————————
    // ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。
    //    {
    //        function log(x, y) {
    //            y = y || 'World!'
    //            console.log(x, y)
    //        }
    //        log('Hello')  // Hello World!
    //        log('Hello', '朱明宇')  // Hello 朱明宇
    //        log('Hello', '')  // Hello World!
    //        log('Hello', undefined) // Hello World!
    //        log('Hello', null) // Hello World!
    //        log('Hello', true) // Hello true
    //        log('Hello', false) // Hello World!
    //        log('Hello', 0) // Hello World!
    //        log('Hello', 1) // Hello 1
    //    }
    // ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
    //    {
    //        function log(x,y='World！') {
    //            console.log(x,y);
    //        }
    //        log('Hello') // Hello World！
    //        log('Hello','朱明宇') // Hello 朱明宇
    //        log('Hello','') // Hello
    //        log('Hello','undifined') // Hello undifined
    //        log('Hello',null) // Hello null
    //        log('Hello',true) // Hello true
    //        log('Hello',false) // Hello false
    //        log('Hello',0) // Hello 0
    //        log('Hello',1) // Hello 1
    //    }
    // 参数变量是默认声明的，所以不能用let或const再次声明。
    //    {
    //        function f(x=5) {
    //            let x = 1; //Identifier 'x' has already been declared
    //            //const x = 1; // Identifier 'x' has already been declared
    //        }
    //        f(1)
    //    }
    // 也就是说，参数默认值是惰性求值的。
    //    {
    //        let x = 99;
    //        function f(p = x + 1) {
    //            console.log(p)
    //        }
    //        f(50)
    //        f()
    //    }


    //与解构赋值默认值结合使用
    // 参数默认值可以与解构赋值的默认值，结合起来使用。
    //    {
    //        function f({x, y = 100}) {
    //            console.log(x, y)
    //        }
    //        f({}) // undefined 100
    //        f({x: 20}) // 20 100
    //        f({x: 20, y: undefined}) // 20 100
    //        f({x: 20, y: 50}) // 20 50
    //        f() // Cannot destructure property `x` of 'undefined' or 'null'.
    //    }

    //    {
    //        function f({x, y = 100} = {}) {
    //            console.log(x, y)
    //        }
    //        f()  //  undefined 100  就不会报错了
    //    }


    // 作为练习，请问下面两种写法有什么差别？
    //    {
    //        // 写法一
    //        function m1({x = 0, y = 0} = {}) {
    //            console.log(x, y);
    //        }
    //
    //        // 写法二
    //        function m2({x, y} = {x: 0, y: 0}) {
    //            console.log(x, y);
    //        }
    //        // 函数没有参数的情况
    //        m1()   // 0 0
    //        m2()  // 0 0
    //        // x 和 y都有值的情况
    //        m1({x: 1, y: 1})  // 1 1
    //        m2({x: 1, y: 1}) // 1 1
    //        // 一个有值 一个没值
    //        m1({x:1})  // 1 0
    //        m2({y:1})  // undefined 1
    //        // x 和 y都没有值
    //        m1({}) // 0 0
    //        m2({}) // undefined undefined
    //    }


    // 参数默认值的位置
    /*通常情况下，定义了默认值的参数，
     应该是函数的尾参数。因为这样比较容易看出来，
     到底省略了哪些参数。如果非尾部的参数设置默认值，
     实际上这个参数是没法省略的。*/
    //    {
    //        function f(x = 1, y) {
    //            console.log(x, y)
    //        }
    //        f()  // 1 undefined
    //        f(2) // 2 undefined
    //         f(,3)// SyntaxError: Unexpected token ,
    //    }


    // 函数的 length 属性
    // 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
    //    {
    //        console.log(function f1(x) {}.length)  // 1
    //        console.log(function f1(x=1) {}.length)  // 0
    //        console.log(function f1(x,y) {}.length)  // 2
    //    }
    //这是因为length属性的含义是，该函数预期传入的参数个数
    //    {
    //        console.log(function f1(...args) {}.length)  // 0
    //    }
    // 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。
    //    {
    //        console.log(function f(x = 1, y, z) {}.length)   // 0
    //        console.log(function f(x , y = 0, z) {}.length)   // 1
    //    }


    // 作用域
    /*一旦设置了参数的默认值，函数进行声明初始化时，
     参数会形成一个单独的作用域（context）。等到初始化结束，
     这个作用域就会消失。这种语法行为，在不设置参数默认值时，
     是不会出现的。*/
    //    {
    //        let x = 1;
    //        function f(x, y = x) {
    //            console.log(y)
    //        }
    //        f(2);  // 2
    //    }
    /*上面代码中，参数y的默认值等于变量x。
     调用函数f时，参数形成一个单独的作用域。
     在这个作用域里面，默认值变量x指向第一个参数x，
     而不是全局变量x，所以输出是2。*/

    //    {
    //        let x = 1;
    //        function f(y = x) {
    //            let x = 2;
    //            console.log(y);
    //        }
    //        f() // 1
    //    }

    // 如果此时，全局变量x不存在，就会报错。
    //    {
    //        function f(y = x) {
    //            let x = 2;
    //            console.log(y)
    //        }
    //        f() // ReferenceError: x is not defined
    //    }

    //    {
    //        let x = 1;
    //        function f(x = x) {
    //            console.log(x)
    //        }
    //        f() //  ReferenceError: x is not defined
    //    }
    // 上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。

    // 如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。
    //    {
    //        let x = 456;
    //        function f(y = () => x) {
    //            let x = 789;
    //            console.log(y())
    //        }
    //        f() // 456
    //    }

    // 更复杂的例子
    //    {
    //        var x = 1;
    //
    //        function f(x, y = () => {
    //            console.log(x);
    //            x = 2;
    //        }) {
    //            var x = 3;
    //            y() // undefined
    //            console.log(x) // 3
    //        }
    //
    //        f()
    //        console.log(x) // 1
    //    }
    // 和
    //    {
    //        var x = 1;
    //        function f(x, y = () => {
    //            console.log(x);
    //            x = 2;
    //        }) {
    //            x = 3;
    //            y()
    //            console.log(x);
    //        }
    //        f()
    //    }


    // 应用
    // 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。
    //    {
    //        function throwIfMissing() {
    //            throw new Error('Missing parameter');
    //        }
    //        function foo(mustBeProvided = throwIfMissing()) {
    //            return mustBeProvided;
    //        }
    //        foo()  // Missing parameter
    //    }


    // ——————————————————————02. rest参数 ——————————————————————————
    /*ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，
     这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，
     该变量将多余的参数放入数组中。*/
    //    {
    //        function add(...rests) {
    //            let sum = 0;
    //            for (let n of rests) {
    //                sum += n;
    //            }
    //            return sum;
    //        }
    //        console.log(add(1, 2, 3, 4, 5)) // 15
    //    }

    // 下面是一个 rest 参数代替arguments变量的例子。
    //    {
    //        // arguments变量的写法
    //        function sortNumbers1() {
    //            return Array.prototype.slice.call(arguments).sort();
    //        }
    //        console.log(sortNumbers1(5, 2, 6, 3, 4, 1)) // [1, 2, 3, 4, 5, 6]
    //        // rest参数的写法
    //        const sortNumbers2 = (...numbers) => numbers.sort();
    //        console.log(sortNumbers2(5, 2, 6, 3, 4, 1)) // [1, 2, 3, 4, 5, 6]
    //    }

    /*arguments对象不是数组，而是一个类似数组的对象。
     所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。
     rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。*/

    // 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
    //    {
    //        function f(a, ...b, c) {
    //        }  // SyntaxError: Rest parameter must be last formal parameter
    //    }

    // 函数的length属性，不包括 rest 参数。
    //    {
    //        console.log(function (a) {}.length) // 1
    //        console.log(function (a,...b) {}.length) // 1
    //        console.log(function (...b) {}.length) // 0
    //    }


    // ——————————————————————03. 严格模式 ——————————————————————————
    // 从 ES5 开始，函数内部可以设定为严格模式。
    //    {
    //        function doSomething(a, b) {
    //            'use strict';
    //            // code
    //        }
    //    }

    // ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。
    //    {
    //        // 报错
    //        function doSomething(a, b = a) {
    //            'use strict';
    //            // code
    //        } // SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list
    //
    //        // 报错
    //        const doSomething = function ({a, b}) {
    //            'use strict';
    //            // code
    //        };
    //
    //        // 报错
    //        const doSomething = (...a) => {
    //            'use strict';
    //            // code
    //        };
    //
    //        const obj = {
    //            // 报错
    //            doSomething({a, b}) {
    //                'use strict';
    //                // code
    //            }
    //        };
    //    }

    /*函数内部的严格模式，同时适用于函数体和函数参数。
     但是，函数执行的时候，先执行函数参数，然后再执行函数体。
     这样就有一个不合理的地方，只有从函数体之中，
     才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。*/
    //    {
    //        // 报错
    //        function doSomething(value = 070) {
    //            'use strict';
    //            // SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list
    //        }
    //    }


    // ——————————————————————04. name属性 ——————————————————————————
    // 函数的name属性，返回该函数的函数名。
    {
        function f() {

        }
        console.log(f.name)
    }






</script>