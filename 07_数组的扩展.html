<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

</body>
</html>

<script type="text/javascript">
    // ——————————————————————01.  扩展运算符——————————————————————————
    // 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
    //    {
    //        console.log(...[1, 2, 3]) // 1 2 3
    //        console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5
    //    }
    // 该运算符主要用于函数调用。
    //    {
    //        function push(array, ...items) {
    //            array.push(...items);
    //        }
    //        let array = [];
    //        push(array, 1, 2, 3, 4, 5, 6, 7, 8)
    //        console.log(array)   // [1,2,3,4,5,6,7,8]
    //
    //        const array2 = [2, 38];
    //        function add(x, y) {
    //            return x + y;
    //        }
    //        console.log(add(...array2))  // 40
    //    }

    // 扩展运算符与正常的函数参数可以结合使用，非常灵活
    //    {
    //        function f(a, b, c, d, e, f) {
    //            for (let i = 0; i < arguments.length; i++) {
    //                console.log(arguments[i])
    //            }
    //        }
    //        let args = [2, 3];
    //        f(1, ...args, 4, ...[5])
    //    }

    // 扩展运算符后面还可以放置表达式。
    //    {
    //        console.log(...(5 > 0 ? [1, 2, 3, 4] : []));  // 1 2 3 4
    //    }

    // 如果扩展运算符后面是一个空数组，则不产生任何效果。
    //    {
    //        console.log([...[], 123])  // [123]
    //    }

    // 注意，扩展运算符如果放在括号中，JavaScript 引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。
    //    {
    //        console.log((...[1, 2])) //  SyntaxError: Unexpected number
    //        console.log(...[1, 2]) //  正确
    //    }


    // 替代函数的 apply 方法
    // 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。
    //    {
    //        // ES5 的写法
    //        function f(x, y, z) {
    //            // ...
    //            console.log(x, y, z)
    //        }
    //
    //        var args = [0, 1, 2];
    //        f.apply(null, args);
    //    }
    //    {
    //        // ES6写法
    //        function f(x, y, z) {
    //            // ...
    //            console.log(x, y, z)
    //        }
    //        let args = [0, 1, 2];
    //        f(...args);
    //    }

    // 实例 求最大数
    //    {
    //        let array = [45, 89, 26, 474, 474];
    //        // ES5写法
    //        console.log(Math.max.apply(null, array));  // 474
    //        // ES6 扩展运算符
    //        console.log(Math.max(...array))  // 474
    //        // 普通写法
    //        console.log(Math.max(45, 89, 26, 474, 474)) // 474
    //    }


    // 扩展运算符的应用
    // （1）复制数组
    // 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。
    //    {
    //        let a1 = [0, 1];
    //        let a2 = a1;
    //        a2[0] = 1;
    //        console.log(a1);  // [1,1]
    //    }
    // 上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。
    //ES5 只能用变通方法来复制数组。
    //    {
    //        let a1 = [0, 1];
    //        let a2 = a1.concat();
    //        console.log(a2); // [0, 1]
    //        a2[0] = 1;
    //        console.log(a1); // [0, 1]
    //        console.log(a2) // [1, 1]
    //    }
    // 上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。
    // 扩展运算符提供了复制数组的简便写法。
    //    {
    //        const a1 = [1, 2];
    //        // 写法一
    //        const a2 = [...a1];
    //        // 写法二
    //        const [...a2] = a1;
    //    }


    // （2）合并数组
    // 扩展运算符提供了数组合并的新写法。
    //    {
    //        const arr1 = ['a', 'b'];
    //        const arr2 = ['c'];
    //        const arr3 = ['d', 'e'];
    //
    //        // ES5 的合并数组
    //        arr1.concat(arr2, arr3);
    //        // [ 'a', 'b', 'c', 'd', 'e' ]
    //
    //        // ES6 的合并数组
    //        [...arr1, ...arr2, ...arr3]
    //        // [ 'a', 'b', 'c', 'd', 'e' ]
    //    }
    // 不过，这两种方法都是浅拷贝，使用的时候需要注意。
    //    {
    //        const a1 = [{ foo: 1 }];
    //        const a2 = [{ bar: 2 }];
    //
    //        const a3 = a1.concat(a2);
    //        const a4 = [...a1, ...a2];
    //
    //        a3[0] === a1[0] // true
    //        a4[0] === a1[0] // true
    //    }
    // 上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。


    // （3）与解构赋值结合
    // 扩展运算符可以与解构赋值结合起来，用于生成数组。
    //    {
    //        const [first, ...rest] = [1, 2, 3, 4, 5];
    //        first // 1
    //        rest  // [2, 3, 4, 5]
    //
    //        const [first, ...rest] = [];
    //        first // undefined
    //        rest  // []
    //
    //        const [first, ...rest] = ["foo"];
    //        first  // "foo"
    //        rest   // []
    //    }
    // 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
    //    {
    //        const [...butLast, last] = [1, 2, 3, 4, 5];
    //        // 报错
    //        const [first, ...middle, last] = [1, 2, 3, 4, 5];
    //        // 报错
    //
    //        //SyntaxError: Rest element must be last element
    //    }

    // （4）字符串
    // 扩展运算符还可以将字符串转为真正的数组。
    //    {
    //        console.log([...'hello'])
    //    }
    // 上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。
    //    {
    //        console.log('x\uD83D\uDE80y'.length)  // 4
    //        console.log([...'x\uD83D\uDE80y'].length)  // 3
    //        console.log('x\uD83D\uDE80y')  //  x🚀y
    //    }
    /*上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，
     识别为 2 个字符，采用扩展运算符就没有这个问题。
     因此，正确返回字符串长度的函数，可以像下面这样写。*/
    //    {
    //        function length(str) {
    //            return [...str].length;
    //        }
    //        console.log(length('x🚀y'))  // 3
    //        console.log(length('x\uD83D\uDE80y'))  // 3
    //    }


    // （5）实现了 Iterator 接口的对象
    // 任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。
    //
    // {
    //     let nodeList = document.querySelectorAll('div');
    //     let array = [...nodeList];
    // }
    /*上面代码中，querySelectorAll方法返回的是一个NodeList对象。
     它不是数组，而是一个类似数组的对象。
     这时，扩展运算符可以将其转为真正的数组，
     原因就在于NodeList对象实现了 Iterator 。*/

    // {
    //     Number.prototype[Symbol.iterator] = function *() {
    //         let i = 0;
    //         let num = this.valueOf();
    //         while (i<num){
    //             yield i++;
    //         }
    //     }
    //     console.log(...5)
    // }
    //上面代码中，先定义了Number对象的遍历器接口，扩展运算符将5自动转成Number实例以后，就会调用这个接口，就会返回自定义的结果。
    // 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。
    // {
    //     let arrayLike = {
    //         '0': 'a',
    //         '1': 'b',
    //         '2': 'c',
    //         length: 3
    //     };
    //     let arr = [...arrayLike];  // TypeError: arrayLike is not iterable
    // }
    /*上面代码中，arrayLike是一个类似数组的对象，
     但是没有部署 Iterator 接口，扩展运算符就会报错。
     这时，可以改为使用Array.from方法将arrayLike转为真正的数组。*/


    // （6）Map 和 Set 结构，Generator 函数
    // 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。
    // {
    //     let map = new Map([
    //         [1, 'one'],
    //         [2, 'two'],
    //         [3, 'three'],
    //     ]);
    //
    //     let arr = [...map.keys()]; // [1, 2, 3]
    //     console.log(arr)
    //     console.log([...map.values()])
    // }
    // Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。
    // {
    //     const go = function* () {
    //         yield 1;
    //         yield 2;
    //         yield 3;
    //     };
    //
    //     console.log([...go()]) // [1, 2, 3]
    // }
    /*上面代码中，变量go是一个 Generator 函数，
     执行后返回的是一个遍历器对象，
     对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，
     转为一个数组。*/
    //如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。
    // {
    //     const obj = {a: 1, b: 2};
    //     let arr = [...obj]; // TypeError: obj is not iterable
    // }


    // ——————————————————————02  Array.from()——————————————————————————
    // Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。

    // 下面是一个类似数组的对象，Array.from将它转为真正的数组。
    //    {
    //        let arrayLike = {
    //            '0': 'a',
    //            '1': 'b',
    //            '2': 'c',
    //            length: 3
    //        };
    //        // es 5
    //        console.log([].slice.call(arrayLike))
    //        // es6
    //        console.log(Array.from(arrayLike))
    //    }

    // 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。
    //    {
    //        function f() {
    //            console.log(Array.from(arguments))
    //        }
    //        f(1,2,3,4,5,6)
    //    }

    // 只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。
    //    {
    //        console.log(Array.from('hello'))
    //        console.log(Array.from(new Set(['a',"b"])))
    //    }
    // 上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。

    // 如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。
    //    {
    //        console.log(Array.from([1,2,3,4,5]))
    //    }

    // 值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。
    //    {
    //        function f() {
    //            console.log([...arguments])
    //        }
    //        f(1,2,3,4,5,6)
    //    }

    // 任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。
    //    {
    //        let obj = {length: 3};
    //        console.log(Array.from(obj))  // [undefined, undefined, undefined]
    //        console.log([...obj])   // 报错  TypeError: obj is not iterable
    //    }

    // 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。
    //    {
    //        let obj = {length: 3};
    //        console.log([].slice.call(obj))  // [empty × 3]
    //    }


    // Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。
    //    {
    //        console.log(Array.from([1, 2, 3, 4, 5], x => x * x));  // [1, 4, 9, 16, 25]
    //        // 等同于
    //        Array.from([1, 2, 3, 4, 5]).map(x => x * x);
    //    }
    // 下面的例子将数组中布尔值为false的成员转为0。
    //    {
    //        let arr = [1, , 2, false, 3, true,null,NaN,'4'*1];
    //        console.log(Array.from(arr, n => n || 0))
    //    }
    // 另一个例子是返回各种数据的类型
    //    {
    //        function f() {
    //            Array.from(arguments, n => {
    //                let x = n ? true : false;
    //                console.log(n+'---------'+x)
    //                return x;
    //            })
    //        }
    //        f(0, 1, 2, '0', '1', undefined, null, NaN)
    //    }

    //
    //    {
    //        console.log(Array.from({ length: 2 }, () => 'jack'))
    //    }

    /**
     *  Array.from()的另一个应用是，将字符串转为数组，
     *  然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，
     *  可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，
     *  算作两个字符的 bug。
     */
    //    {
    //        let s = 'x🚀y';
    //        console.log('原字符串-----'+s)
    //        console.log('普通的返回长度-----'+s.length);
    //        console.log('Array.from的返回长度-----'+Array.from(s).length);
    //        console.log('扩展运算符的返回长度-----'+[...s].length);
    //    }


    // ——————————————————————03. Array.of()——————————————————————————
    // Array.of方法用于将一组值，转换为数组。
    //    {
    //        console.log(Array.of(1,2,3,4,5))  // [1, 2, 3, 4, 5]
    //        console.log(Array.of(3))  // [3]
    //        console.log(Array.of(3).length)  // 1
    //    }

    // 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。
    //    {
    //        console.log(new Array())  // []  空数组
    //        console.log(new Array(4))  //  长度为4的空数组
    //        console.log(new Array(1, 2))  //  数组  [1, 2]
    //    }

    // Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。
    //    {
    //        console.log(Array.of()) // []
    //        console.log(Array.of(undefined)) // [undefined]
    //        console.log(Array.of(null)) // [null]
    //        console.log(Array.of(1,2)) // [1,2]
    //    }

    // Array.of方法可以用下面的代码模拟实现。
    //    {
    //        function ArrayOf() {
    //            return [].slice.call(arguments);
    //        }
    //        console.log(ArrayOf(undefined))
    //    }


    // ——————————————————————04. 数组实例的 copyWithin()——————————————————————————
    /*数组实例的copyWithin方法，在当前数组内部，
     将指定位置的成员复制到其他位置（会覆盖原有成员），
     然后返回当前数组。也就是说，使用这个方法，
     会修改当前数组。*/
    //    {
    //        Array.prototype.copyWithin(target, start = 0, end = this.length)
    //    }
    /*它接受三个参数。
     target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
     start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。
     end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。*/
    // 这三个参数都应该是数值，如果不是，会自动转为数值。
    //    {
    //        let arr = [1,2,3,4,5];
    //        arr.copyWithin(0,3);   // 改变原数组
    //        console.log(arr)  // [4, 5, 3, 4, 5]
    //    }
    // 上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。

    {
        // 将3号位复制到0号位
        console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4))
    }



</script>