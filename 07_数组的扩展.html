<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

</body>
</html>

<script type="text/javascript">
    // ——————————————————————01.  扩展运算符——————————————————————————
    // 扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
    //    {
    //        console.log(...[1, 2, 3]) // 1 2 3
    //        console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5
    //    }
    // 该运算符主要用于函数调用。
    //    {
    //        function push(array, ...items) {
    //            array.push(...items);
    //        }
    //        let array = [];
    //        push(array, 1, 2, 3, 4, 5, 6, 7, 8)
    //        console.log(array)   // [1,2,3,4,5,6,7,8]
    //
    //        const array2 = [2, 38];
    //        function add(x, y) {
    //            return x + y;
    //        }
    //        console.log(add(...array2))  // 40
    //    }

    // 扩展运算符与正常的函数参数可以结合使用，非常灵活
    //    {
    //        function f(a, b, c, d, e, f) {
    //            for (let i = 0; i < arguments.length; i++) {
    //                console.log(arguments[i])
    //            }
    //        }
    //        let args = [2, 3];
    //        f(1, ...args, 4, ...[5])
    //    }

    // 扩展运算符后面还可以放置表达式。
    //    {
    //        console.log(...(5 > 0 ? [1, 2, 3, 4] : []));  // 1 2 3 4
    //    }

    // 如果扩展运算符后面是一个空数组，则不产生任何效果。
    //    {
    //        console.log([...[], 123])  // [123]
    //    }

    // 注意，扩展运算符如果放在括号中，JavaScript 引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。
    //    {
    //        console.log((...[1, 2])) //  SyntaxError: Unexpected number
    //        console.log(...[1, 2]) //  正确
    //    }


    // 替代函数的 apply 方法
    // 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。
    //    {
    //        // ES5 的写法
    //        function f(x, y, z) {
    //            // ...
    //            console.log(x, y, z)
    //        }
    //
    //        var args = [0, 1, 2];
    //        f.apply(null, args);
    //    }
    //    {
    //        // ES6写法
    //        function f(x, y, z) {
    //            // ...
    //            console.log(x, y, z)
    //        }
    //        let args = [0, 1, 2];
    //        f(...args);
    //    }

    // 实例 求最大数
    //    {
    //        let array = [45, 89, 26, 474, 474];
    //        // ES5写法
    //        console.log(Math.max.apply(null, array));  // 474
    //        // ES6 扩展运算符
    //        console.log(Math.max(...array))  // 474
    //        // 普通写法
    //        console.log(Math.max(45, 89, 26, 474, 474)) // 474
    //    }


    // 扩展运算符的应用
    // （1）复制数组
    // 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。
    //    {
    //        let a1 = [0, 1];
    //        let a2 = a1;
    //        a2[0] = 1;
    //        console.log(a1);  // [1,1]
    //    }
    // 上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。
    //ES5 只能用变通方法来复制数组。
    //    {
    //        let a1 = [0, 1];
    //        let a2 = a1.concat();
    //        console.log(a2); // [0, 1]
    //        a2[0] = 1;
    //        console.log(a1); // [0, 1]
    //        console.log(a2) // [1, 1]
    //    }
    // 上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。
    // 扩展运算符提供了复制数组的简便写法。
    //    {
    //        const a1 = [1, 2];
    //        // 写法一
    //        const a2 = [...a1];
    //        // 写法二
    //        const [...a2] = a1;
    //    }


    // （2）合并数组
    // 扩展运算符提供了数组合并的新写法。
    //    {
    //        const arr1 = ['a', 'b'];
    //        const arr2 = ['c'];
    //        const arr3 = ['d', 'e'];
    //
    //        // ES5 的合并数组
    //        arr1.concat(arr2, arr3);
    //        // [ 'a', 'b', 'c', 'd', 'e' ]
    //
    //        // ES6 的合并数组
    //        [...arr1, ...arr2, ...arr3]
    //        // [ 'a', 'b', 'c', 'd', 'e' ]
    //    }
    // 不过，这两种方法都是浅拷贝，使用的时候需要注意。
    //    {
    //        const a1 = [{ foo: 1 }];
    //        const a2 = [{ bar: 2 }];
    //
    //        const a3 = a1.concat(a2);
    //        const a4 = [...a1, ...a2];
    //
    //        a3[0] === a1[0] // true
    //        a4[0] === a1[0] // true
    //    }
    // 上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。


    // （3）与解构赋值结合
    // 扩展运算符可以与解构赋值结合起来，用于生成数组。
    //    {
    //        const [first, ...rest] = [1, 2, 3, 4, 5];
    //        first // 1
    //        rest  // [2, 3, 4, 5]
    //
    //        const [first, ...rest] = [];
    //        first // undefined
    //        rest  // []
    //
    //        const [first, ...rest] = ["foo"];
    //        first  // "foo"
    //        rest   // []
    //    }
    // 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
    //    {
    //        const [...butLast, last] = [1, 2, 3, 4, 5];
    //        // 报错
    //        const [first, ...middle, last] = [1, 2, 3, 4, 5];
    //        // 报错
    //
    //        //SyntaxError: Rest element must be last element
    //    }

    // （4）字符串
    // 扩展运算符还可以将字符串转为真正的数组。
    //    {
    //        console.log([...'hello'])
    //    }
    // 上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。
    //    {
    //        console.log('x\uD83D\uDE80y'.length)  // 4
    //        console.log([...'x\uD83D\uDE80y'].length)  // 3
    //        console.log('x\uD83D\uDE80y')  //  x🚀y
    //    }
    /*上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，
     识别为 2 个字符，采用扩展运算符就没有这个问题。
     因此，正确返回字符串长度的函数，可以像下面这样写。*/
    //    {
    //        function length(str) {
    //            return [...str].length;
    //        }
    //        console.log(length('x🚀y'))  // 3
    //        console.log(length('x\uD83D\uDE80y'))  // 3
    //    }


    // （5）实现了 Iterator 接口的对象
    // 任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。
    //
    // {
    //     let nodeList = document.querySelectorAll('div');
    //     let array = [...nodeList];
    // }
    /*上面代码中，querySelectorAll方法返回的是一个NodeList对象。
    它不是数组，而是一个类似数组的对象。
    这时，扩展运算符可以将其转为真正的数组，
    原因就在于NodeList对象实现了 Iterator 。*/

    // {
    //     Number.prototype[Symbol.iterator] = function *() {
    //         let i = 0;
    //         let num = this.valueOf();
    //         while (i<num){
    //             yield i++;
    //         }
    //     }
    //     console.log(...5)
    // }
    //上面代码中，先定义了Number对象的遍历器接口，扩展运算符将5自动转成Number实例以后，就会调用这个接口，就会返回自定义的结果。
    // 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。
    // {
    //     let arrayLike = {
    //         '0': 'a',
    //         '1': 'b',
    //         '2': 'c',
    //         length: 3
    //     };
    //     let arr = [...arrayLike];  // TypeError: arrayLike is not iterable
    // }
    /*上面代码中，arrayLike是一个类似数组的对象，
    但是没有部署 Iterator 接口，扩展运算符就会报错。
    这时，可以改为使用Array.from方法将arrayLike转为真正的数组。*/


    // （6）Map 和 Set 结构，Generator 函数
    // 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。
    // {
    //     let map = new Map([
    //         [1, 'one'],
    //         [2, 'two'],
    //         [3, 'three'],
    //     ]);
    //
    //     let arr = [...map.keys()]; // [1, 2, 3]
    //     console.log(arr)
    //     console.log([...map.values()])
    // }
    // Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。
    // {
    //     const go = function* () {
    //         yield 1;
    //         yield 2;
    //         yield 3;
    //     };
    //
    //     console.log([...go()]) // [1, 2, 3]
    // }
    /*上面代码中，变量go是一个 Generator 函数，
    执行后返回的是一个遍历器对象，
    对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，
    转为一个数组。*/
    //如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。
    // {
    //     const obj = {a: 1, b: 2};
    //     let arr = [...obj]; // TypeError: obj is not iterable
    // }


</script>