<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <img src="lidan.jpg">
</body>
</html>

<script type="text/javascript">
    // ——————————————————————01. 属性的简洁表示法 ——————————————————————————
    // ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
    // ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
    //    {
    //        let a = 'a';
    //        let b = {b: a};
    //        console.log(b)
    //    }
    // 上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。
    //    {
    //        function f(x, y) {
    //            return {x, y};
    //        }
    //
    //        // 等同于
    //        //        function f(x, y) {
    //        //            return {x: x, y: y};
    //        //        }
    //        console.log(f(1, 2))    // Object {x: 1, y: 2}
    //    }

    // CommonJS 模块输出一组变量，就非常合适使用简洁写法
    //    {
    //        let ms = {};
    //        function getItem (key) {
    //            return key in ms ? ms[key] : null;
    //        }
    //        function setItem (key, value) {
    //            ms[key] = value;
    //        }
    //        function clear () {
    //            ms = {};
    //        }
    //        module.exports = { getItem, setItem, clear };
    //        // 等同于
    //        module.exports = {
    //            getItem: getItem,
    //            setItem: setItem,
    //            clear: clear
    //        };
    //    }


    // ——————————————————————02. 属性名表达式 ——————————————————————————
    // JavaScript 定义对象的属性，有两种方法。
    //    {
    //        let obj = {};
    //        obj.foo = 'a';
    //        obj['a' + 'bc'] = 'abc123';
    //        console.log(obj)  // {foo: "a", abc: "abc123"}
    //    }
    // ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。
    //    {
    //        let propKey = 'foo';
    //        let obj = {
    //            [propKey]: 'a',
    //            ['a' + 'bc']: 'abc123'
    //        };
    //        console.log(obj)        // {foo: "a", abc: "abc123"}
    //    }

    // 表达式还可以用于定义方法名。
    //    {
    //        let obj = {
    //            ['h' + 'ello']() {
    //                return 'hi';
    //            }
    //        };
    //        console.log(obj.hello())   // hi
    //    }

    // 注意，属性名表达式与简洁表示法，不能同时使用，会报错。
    //    {
    //        // 报错
    //        const foo = 'bar';
    //        const bar = 'abc';
    //        const baz = { [foo] };  // SyntaxError: Unexpected token
    //        // 正确
    //        const foo = 'bar';
    //        const baz = { [foo]: 'abc'};
    //    }
    // 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。
    //    {
    //        const keyA = {a: 1};
    //        const keyB = {b: 2};
    //
    //        const myObject = {
    //            [keyA]: 'valueA',
    //            [keyB]: 'valueB'
    //        };
    //
    //        console.log(myObject)   // {[object Object]: "valueB"}   因为被覆盖了  所以只有一个属性
    //    }


    // ——————————————————————03. 方法的 name 属性 ——————————————————————————
    // 函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。
    //    {
    //        let obj = {
    //            say:function () {
    //                console.log('hello')
    //            }
    //        }
    //        obj.say()
    //        console.log(obj.say.name)
    //    }

    // 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。
    //    {
    //        var doSomething = function () {
    //            // ...
    //        }
    //        console.log(doSomething.bind().name)    // bound doSomething
    //
    //        // 匿名函数
    //        console.log((new Function()).name);   // anonymous
    //    }




</script>