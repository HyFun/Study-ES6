<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

</body>
</html>

<script type="text/javascript">
    // ——————————————————————01.  ——————————————————————————
    // ——————————————————————01.  Set——————————————————————————
    //    ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
    //    {
    //        const s = new Set();
    //
    //        [2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
    //
    //        for (let i of s) {
    //            console.log(i);
    //        }
    //    }


    // 不同类型的值可以添加
    //    {
    //        const set = new Set();
    //        set.add(5);
    //        set.add('5');
    //        console.log(set)
    //    }


    // NaN 只能添加一个
    //    {
    //        const set = new Set([NaN, NaN]);
    //        console.log(set)
    //    }

    // Set 的构造参数  只能是拥有Iterator接口类型的参数 才能初始化Set
    //    {
    //        const set = new Set([1, 2, 3, 4, 5, 6, 6, 6, 7, 7, 8, 8]);
    //        console.log(set)
    //        const set2 = new Set([Symbol.for('a'), Symbol.for('a'), Symbol.for('a'), Symbol('a'), Symbol('a'), Symbol('a')]);
    //        console.log(set2)
    //    }


    // ——————————————————————02.     Set 实例的属性和方法——————————————————————————
    //    add(value)：添加某个值，返回 Set 结构本身。
    //    delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
    //    has(value)：返回一个布尔值，表示该值是否为Set的成员。
    //    clear()：清除所有成员，没有返回值。
    //    {
    //        const set = new Set([1, 2, 3]);
    //        // size 属性
    //        console.log(set.size)
    //
    //        // add 方法
    //        set.add('3');
    //        console.log(set)
    //        // delete
    //        set.delete(1);
    //        console.log(set)
    //        // has
    //        console.log(set.has(2))
    //        console.log(set)
    //
    //        // 清空所有
    //        set.clear();
    //        console.log(set)
    //    }


    // 判断属性是否存在
    //    {
    //        let object = {
    //            width: 156,
    //            height: 200,
    //        };
    //        // 常规判断方法
    //        console.log(Boolean(object.width)) // true
    //        console.log(Boolean(object.widget)) // fase
    //
    //        //set 方法
    //        const set = new Set(Object.keys(object));
    //        console.log(set.has('width')) // true
    //        console.log(set.has('widget')) // false
    //    }

    // Array.from方法可以将 Set 结构转为数组。
    //    {
    //        const set = new Set([1, 2, 3, 4]);
    //        console.log(Array.from(set))
    //        console.log(...set)
    //    }

    // 数组去重方法
    //    {
    //        function f1(array) {
    //            return Array.from(new Set(array));
    //        }
    //
    //        function f2(array) {
    //            return [...new Set(array)];
    //        }
    //
    //        console.log(f1([1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3]))
    //        console.log(f2([1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3]))
    //    }


    // 遍历操作
    /*Set 结构的实例有四个遍历方法，可以用于遍历成员。
     keys()：返回键名的遍历器
     values()：返回键值的遍历器
     entries()：返回键值对的遍历器
     forEach()：使用回调函数遍历每个成员*/

    //    {
    //        let set = new Set(['red', 'green', 'blue']);
    //
    //        for (let item of set.keys()) {
    //            console.log(item);
    //        }
    //        // red
    //        // green
    //        // blue
    //
    //        for (let item of set.values()) {
    //            console.log(item);
    //        }
    //        // red
    //        // green
    //        // blue
    //
    //        for (let item of set.entries()) {
    //            console.log(item);
    //        }
    //        // ["red", "red"]
    //        // ["green", "green"]
    //        // ["blue", "blue"]
    //    }

    // 这意味着，可以省略values方法，直接用for...of循环遍历 Set。
    //    {
    //        let set = new Set(['red', 'green', 'blue']);
    //        for (let x of set) {
    //            console.log(x);
    //        }
    //        // red
    //        // green
    //        // blue
    //    }

    // for each
    //    {
    //        let set = new Set(['red', 'green', 'blue']);
    //        set.forEach((value, key) => {
    //            console.log(key, value)
    //        })
    //    }

    //遍历的应用
    //    {
    //        let set = new Set([1, 2, 3, 4, 4, 4]);
    //        console.log([...set])
    //    }


    // ——————————————————————02. WeakSet——————————————————————————
    /*WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。
     首先，WeakSet 的成员只能是对象，而不能是其他类型的值。*/
    /*WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，
     遍历机制无法保证成员的存在，很可能刚刚遍历结束，
     成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，
     而不用担心这些节点从文档移除时，会引发内存泄漏。*/

    // ——————————————————————02. Map——————————————————————————
    // 实例的属性和操作方法
    //    {
    //        const map = new Map();
    //        // size
    //        map.set('a', 'a');
    //        map.set('b', 'b');
    //        console.log(map.size) // 2
    //        // set()方法
    //        map.set('c', 'c');
    //        // get(key) 获取对应key的value
    //        console.log(map.get('a'))
    //        // has(key)    has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。
    //        console.log(map.has('a'))
    //        // delete(key)   delete方法删除某个键，返回true。如果删除失败，返回false。
    //        console.log(map.delete('a'))
    //        //  clear
    //        map.clear();
    //        console.log(map)
    //    }


    // 遍历方法
    //    Map 结构原生提供三个遍历器生成函数和一个遍历方法。
    //
    //    keys()：返回键名的遍历器。
    //    values()：返回键值的遍历器。
    //    entries()：返回所有成员的遍历器。
    //    forEach()：遍历 Map 的所有成员。
    //    {
    //        const map = new Map();
    //        map.set("name", "朱明宇");
    //        map.set("height", "170");
    //        map.set("weight", "120");
    //
    //        for (let name of map.keys()) {
    //            console.log(name)
    //        }
    //
    //        for (let value of map.values()) {
    //            console.log(value)
    //        }
    //
    //        for (let item of map.entries()) {
    //            console.log(item)
    //        }
    //
    //        map.forEach((v, k) => {
    //            console.log(k, v)
    //        })
    //
    //        for(let [k,v] of map){
    //            console.log(k,v)
    //        }
    //    }


    // map,filter
    //    {
    //        const map0 = new Map()
    //            .set(1, 'a')
    //            .set(2, 'b')
    //            .set(3, 'c');
    //        // filter
    //        const map1 = new Map([...map0].filter(([k, v]) => k < 3));
    //        console.log(map1)
    //        // map
    //        const map2 = new Map([...map0].map(([k, v]) => [Math.pow(k, 2), v]));
    //        console.log(map2)
    //    }

    //forEach方法
    //    {
    //        const map = new Map();
    //        map.set("name", "朱明宇");
    //        map.set("height", "170");
    //        map.set("weight", "120");
    //        map.forEach((v,k,m)=>console.log("Key: %s, Value: %s", k, v))
    //    }
    //forEach方法还可以接受第二个参数，用来绑定this。
    //    {
    //        const student = {
    //            learn: function () {
    //                return '学生学习哦~'
    //            }
    //        }
    //        const map = new Map();
    //        map.set("name", "朱明宇");
    //        map.set("height", "170");
    //        map.set("weight", "120");
    //        map.forEach(function (v, k, map) {
    //            console.log(this.learn(), this)
    //        }, student);
    //    }


    //与其他数据结构的互相转换
    //    {
    //        const map = new Map()
    //            .set("name", "朱明宇")
    //            .set("height", "170")
    //            .set("weight", "120");
    //
    //        //Map 转为数组
    //        {
    //            console.log([...map])
    //        }
    //        //数组 转为 Map
    //        {
    //            console.log(new Map([
    //                ['name1', '朱明宇'],
    //                ['name2', '胡燃烽'],
    //                ['name3', '宋玉清'],
    //                ['name4', '李昊']
    //            ]))
    //        }
    //        // Map 转为对象
    //        {
    //            let obj = {};
    //            map.forEach(function (v, k) {
    //                obj[k] = v;
    //            })
    //            console.log(obj)
    //        }
    //
    //        //对象转为 Map
    //        {
    //            let obj = {name: "朱明宇", height: "170", weight: "120"};
    //            const mapObj = new Map();
    //            for (let name in obj) {
    //                mapObj.set(name, obj[name])
    //            }
    //            console.log(mapObj)
    //        }
    //
    //        // Map 转为 JSON
    //        {
    //            console.log(JSON.stringify(map))
    //        }
    //    }


    // ——————————————————————04. WeakMap——————————————————————————
    //    WeakMap结构与Map结构类似，也是用于生成键值对的集合。

</script>